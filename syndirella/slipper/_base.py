#!venv/bin/env python3
"""
syndirella.slipper._base.py

This module contains the Slipper class. A slipper in this metaphor is the set of molecules that is the
product of a reaction.
"""
from typing import (List, Dict, Tuple, Union, Optional)
import pandas as pd
from syndirella.slipper.slipper_synthesizer._base import SlipperSynthesizer
from syndirella.cobblers_workshop._library import Library
from syndirella.slipper.slipper_fitter._base import SlipperFitter
import os, shutil

class Slipper:
    """
    This class is instantiated to represent all products for a route.
    """
    def __init__(self, final_library: Library, template: str, hits: str, hits_names: List[str], batch_num: int,
                 cluster: bool):
        self.products: pd.DataFrame = None
        self.final_library: Library = final_library
        self.cluster: bool = cluster
        self.output_dir: str = final_library.output_dir
        self.final_products_csv_path: str = None
        # need Fragmenstein information
        self.template: str = template # path to pdb file
        self.hits: str = hits # path to .sdf or .mol file
        self.hits_names: List[str] = hits_names # name of fragments
        self.batch_num: int = batch_num
        self.atom_ids_expansion: dict = None
        self.placements: pd.DataFrame = None
        self.n_cores: int = 8
        self.timeout: int = 240
        self.output_path: str = None

    def get_products(self):
        """
        Main entry to the Slipper class. This function is used to get the products from the final library.
        """
        assert self.atom_ids_expansion is not None, "Atom ids expansion must be set before getting products."
        slipper_synth = SlipperSynthesizer(self.final_library, self.cluster, self.atom_ids_expansion)
        self.products: pd.DataFrame = slipper_synth.get_products()
        slipper_synth.label_products()
        slipper_synth.save_products()
        self.final_products_csv_path: str = slipper_synth.final_products_csv_path
        return self.products

    def place_products(self):
        """
        This function is used to place the products with Fragmenstein.
        """
        slipper_fitter = SlipperFitter(self.products, self.template, self.hits, self.hits_names, self.n_cores,
                                       self.timeout, self.batch_num, self.output_dir, self.final_products_csv_path)
        self.placements: pd.DataFrame = slipper_fitter.fit_products()
        slipper_fitter.save_placements()
        self.output_path: str = slipper_fitter.output_path
        return self.placements

    def clean_up_placements(self):
        """
        This function is used to remove extra files that are generated by Fragmenstein.
        """
        # find output directory
        suffixes_to_keep = ['.minimised.json', '.holo_minimised.pdb', '.minimised.mol', '.csv']
        for root1, dirs, files in os.walk(self.output_path):
            for directory2 in dirs:
                directory2_path = os.path.join(self.output_path, directory2)
                if not os.path.exists(directory2_path):
                    print('THIS PATH DOES NOT EXIST', directory2_path)
                    continue
                for file in os.listdir(directory2_path):
                    if not any(file.endswith(suffix) for suffix in suffixes_to_keep):
                        file_path = os.path.join(self.output_path, directory2, file)
                        try:
                            if os.path.isfile(file_path) or os.path.islink(file_path):
                                os.unlink(file_path)
                                print(f"Deleted file: {file_path}")
                            elif os.path.isdir(file_path):
                                shutil.rmtree(file_path)
                                print(f"Deleted directory: {file_path}")
                        except Exception as e:
                            print('Failed to delete %s. Reason: %s' % (file_path, e))

